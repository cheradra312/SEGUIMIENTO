<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planificador de Estudio Interactivo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        body { 
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        .topic-source-list::-webkit-scrollbar, .calendar-day-topics::-webkit-scrollbar, #day-modal-content::-webkit-scrollbar { width: 6px; }
        .topic-source-list::-webkit-scrollbar-track, .calendar-day-topics::-webkit-scrollbar-track, #day-modal-content::-webkit-scrollbar-track { background: #e5e7eb; border-radius: 10px; }
        .topic-source-list::-webkit-scrollbar-thumb, .calendar-day-topics::-webkit-scrollbar-thumb, #day-modal-content::-webkit-scrollbar-thumb { background: #9ca3af; border-radius: 10px; }
        .topic-source-list::-webkit-scrollbar-thumb:hover, .calendar-day-topics::-webkit-scrollbar-thumb:hover, #day-modal-content::-webkit-scrollbar-thumb:hover { background: #6b7280; }
        
        .calendar-day {
            min-height: 160px;
            transition: all 0.3s ease-in-out;
            cursor: pointer;
            position: relative;
        }
        .drag-over {
            background-color: #c7d2fe !important; /* indigo-200 */
            border: 2px dashed #6366f1; /* indigo-500 */
        }
        .topic-card, .calendar-topic-item {
            cursor: grab;
            transition: all 0.2s ease;
        }
        .topic-card:active, .calendar-topic-item:active {
            cursor: grabbing;
            opacity: 0.8;
            transform: scale(1.05);
        }
        .dragging {
            opacity: 0.5;
            background: #e0e7ff;
        }

        .form-checkbox {
            -webkit-appearance: none; appearance: none;
            background-color: #fff; margin: 0; font: inherit; color: currentColor;
            width: 1.1em; height: 1.1em; border: 0.1em solid #9ca3af;
            border-radius: 0.25em; transform: translateY(-0.075em);
            display: grid; place-content: center; cursor: pointer;
            flex-shrink: 0;
        }
        .form-checkbox::before {
            content: ""; width: 0.65em; height: 0.65em; transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em #4f46e5;
            transform-origin: bottom left;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }
        .form-checkbox:checked { border-color: #4f46e5; }
        .form-checkbox:checked::before { transform: scale(1); }

        .calendar-topic-item {
            padding: 4px;
            font-size: 0.75rem;
            gap: 6px;
        }
        
        .topics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2px;
        }

        .topics-column {
            display: flex;
            flex-direction: column;
            gap: 2px;
            min-width: 0; /* Fix for grid layout issues */
        }

        .calendar-topic-item.in-grid {
            font-size: 0.7rem; /* Adjusted font-size for better fit */
            padding: 2px 4px;
            gap: 4px;
        }
        .calendar-topic-item.in-grid .form-checkbox {
             width: 0.8em; height: 0.8em;
        }
         .calendar-topic-item.in-grid .color-dot {
             width: 0.4rem; height: 0.4rem;
        }
        .calendar-topic-item.in-grid span {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .drop-invalid {
            border: 2px dashed #ef4444 !important; /* red-500 */
        }
        .content-panel.hidden {
            display: none;
        }
        .toggle-icon {
            transition: transform 0.3s ease;
        }
        .collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        aside.collapsed {
            width: 50px !important;
            padding-left: 0.5rem !important;
            padding-right: 0.5rem !important;
            overflow: hidden;
        }
        aside.collapsed > #topics-content {
            display: none;
        }
        aside.collapsed #topics-header h2 {
            display: none;
        }
        aside {
            transition: width 0.3s ease, padding 0.3s ease;
        }
        
        #day-modal-backdrop {
            transition: opacity 0.3s ease-in-out;
        }
        #day-modal-container {
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        #day-modal-backdrop.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #day-modal-container.hidden {
            opacity: 0;
            transform: scale(0.95);
            pointer-events: none;
        }

        #config-panel {
            display: grid;
            grid-template-rows: 0fr;
            transition: grid-template-rows 0.4s ease-in-out;
        }
        #config-panel.expanded {
            grid-template-rows: 1fr;
        }
        .config-panel-inner {
            overflow: hidden;
        }

        /* New styles for unavailable topics */
        .unassign-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0 4px;
            color: #9ca3af; /* gray-400 */
            transition: color 0.2s;
            pointer-events: auto;
        }
        .unassign-btn:hover {
            color: #ef4444; /* red-500 */
        }
        .topic-card.unavailable {
            opacity: 0.6;
            /* cursor is managed with JS now */
        }
        .topic-card.needs-review {
            background-color: #fefce8; /* yellow-50 */
            border: 1px solid #fde047; /* yellow-400 */
        }

        /* Style for multi-selection */
        .topic-card.selected {
            background-color: #c7d2fe; /* indigo-200 */
            border: 1px solid #6366f1; /* indigo-500 */
        }

        /* Security Level Colors */
        .security-20 { background-color: #fecaca; } /* red-200 */
        .security-40 { background-color: #fed7aa; } /* orange-200 */
        .security-60 { background-color: #fef08a; } /* yellow-200 */
        .security-80 { background-color: #d9f99d; } /* lime-200 */
        .security-100 { background-color: #bbf7d0; } /* green-200 */


        /* Block Colors */
        .color-adm { color: #b45309; }
        .color-aguas { color: #0369a1; }
        .color-costas { color: #0e7490; }
        .color-infra { color: #4b5563; }
        .color-trans { color: #059669; }
        .color-ma { color: #15803d; }

        /* Style for highlighting a day on the calendar */
        .highlight-day {
            transform: scale(1.08);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.5s ease;
            z-index: 10;
            box-shadow: 0 0 20px rgba(79, 70, 229, 0.7); /* indigo-600 glow */
            border-color: #4f46e5 !important; /* indigo-600 */
        }
    </style>
</head>
<body class="text-gray-800">

    <div id="login-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-sm">
            <h2 class="text-2xl font-bold mb-4 text-center">Bienvenido</h2>
            <p class="text-gray-600 mb-6 text-center">Introduce un nombre de usuario o ID para guardar y cargar tu progreso.</p>
            <form id="login-form">
                <input type="text" id="username-input" placeholder="Tu nombre de usuario" class="w-full px-4 py-2 border border-gray-300 rounded-lg mb-4" required>
                <button type="submit" class="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition-colors font-semibold">Empezar</button>
            </form>
        </div>
    </div>

    <div id="main-content" class="p-4 md:p-6 hidden">
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <header class="mb-4">
                <div class="flex justify-between items-center">
                    <h1 class="text-3xl md:text-4xl font-bold text-gray-800">Planificador de Estudio Interactivo</h1>
                    <div id="countdown-container" class="text-right">
                        <!-- Countdown will be injected here by JS -->
                    </div>
                </div>
                <p class="text-md text-gray-600 mt-2 text-center">Arrastra los temas al calendario para organizar tu estudio por vueltas.</p>
            </header>
            
            <div class="flex flex-wrap items-center justify-center gap-4">
                 <div>
                    <button id="view-rounds-btn" class="bg-cyan-600 text-white font-semibold px-5 py-2.5 rounded-lg hover:bg-cyan-700 transition-colors shadow-md">
                        <i class="fas fa-tasks mr-2"></i>Ver Vueltas
                    </button>
                    <button id="generate-btn" class="bg-indigo-600 text-white font-semibold px-5 py-2.5 rounded-lg hover:bg-indigo-700 transition-colors shadow-md">
                        <i class="fas fa-sync-alt mr-2"></i>Actualizar Plan
                    </button>
                    <button id="save-btn" class="bg-green-600 text-white font-semibold px-5 py-2.5 rounded-lg hover:bg-green-700 transition-colors shadow-md">
                        <i class="fas fa-save mr-2"></i>Guardar Progreso
                    </button>
                </div>
                <div class="ml-auto flex items-center gap-2">
                    <button id="export-csv-btn" title="Exportar a CSV" class="bg-gray-200 text-gray-600 font-semibold w-10 h-10 text-sm rounded-lg hover:bg-gray-300 transition-colors shadow-md flex items-center justify-center">
                        <i class="fas fa-download"></i>
                    </button>
                    <label for="import-csv-input" title="Importar desde CSV" class="bg-gray-200 text-gray-600 font-semibold w-10 h-10 text-sm rounded-lg hover:bg-gray-300 transition-colors shadow-md cursor-pointer flex items-center justify-center">
                        <i class="fas fa-upload"></i>
                    </label>
                    <input type="file" id="import-csv-input" class="hidden" accept=".csv">
                     <button id="toggle-config-btn" class="bg-gray-700 text-white font-semibold w-10 h-10 rounded-lg hover:bg-gray-800 transition-colors shadow-md flex items-center justify-center">
                        <i class="fas fa-cog"></i>
                    </button>
                </div>
            </div>
            <div id="config-panel">
                <div class="config-panel-inner">
                    <div class="pt-4 mt-4 border-t border-gray-200 flex flex-col md:flex-row items-center justify-center gap-4">
                        <div>
                            <label for="end-date" class="block text-sm font-medium text-gray-700 mb-1">Fecha Límite</label>
                            <input type="text" id="end-date" value="15/09/2025" placeholder="DD/MM/YYYY" class="w-full p-2 border border-gray-300 rounded-lg shadow-sm">
                        </div>
                        <div id="round-durations-container" class="flex flex-wrap items-end justify-center gap-3">
                            <!-- Inputs for round durations will be generated by JS -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="save-status" class="text-center text-sm font-medium h-5 mb-2"></div>
        
        <div id="summary-panel" class="bg-white rounded-xl shadow-lg mb-4">
            <div id="summary-header" class="p-4 cursor-pointer flex justify-between items-center border-b border-transparent">
                <h3 class="font-bold text-lg">Resumen de Progreso</h3>
                <div class="toggle-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z"/></svg>
                </div>
            </div>
            <div id="summary-content" class="p-4 content-panel hidden">
                <div class="mb-4">
                    <label for="summary-round-select" class="block text-sm font-medium text-gray-700 mb-1">Seleccionar Vuelta para el Resumen:</label>
                    <select id="summary-round-select" class="w-full md:w-1/3 p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <div id="summary-table-container" class="overflow-x-auto"></div>
            </div>
        </div>

        <div class="flex flex-row gap-6">
            <aside id="topics-panel" class="lg:w-1/3 bg-white rounded-xl shadow-lg p-4 flex flex-col">
                <div id="topics-header" class="flex justify-between items-center mb-2 cursor-pointer">
                    <h2 class="text-xl font-bold">Temas por Asignar</h2>
                    <div class="toggle-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>
                    </div>
                </div>
                <div id="topics-content" class="content-panel flex-grow flex flex-col">
                    <div class="flex flex-wrap gap-2 items-center border-b border-gray-200 pb-2 mb-2">
                        <div id="round-tabs" class="flex"></div>
                        <div id="sub-block-filter-container" class="flex-grow"></div>
                    </div>
                    <input type="text" id="topic-search" placeholder="Buscar tema..." class="w-full p-2 border border-gray-300 rounded-lg mb-2">
                    <div id="topic-source-list" class="overflow-y-auto flex-grow p-1"></div>
                </div>
            </aside>

            <main class="flex-grow bg-white rounded-xl shadow-lg p-4 flex flex-col">
                <div class="flex justify-between items-center mb-4">
                    <button id="prev-month-btn" class="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">&lt; Anterior</button>
                    <h2 id="calendar-title" class="text-xl font-bold text-center"></h2>
                    <button id="next-month-btn" class="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300">Siguiente &gt;</button> 
                </div>
                <div id="calendar-container" class="grid grid-cols-1 gap-8"></div>
            </main>
        </div>
    </div>
    
    <!-- Day Details Modal -->
    <div id="day-modal-backdrop" class="fixed inset-0 bg-gray-900 bg-opacity-50 z-40 hidden">
        <div id="day-modal-container" class="fixed inset-0 flex items-center justify-center p-4 hidden">
            <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl flex flex-col" style="max-height: 90vh;">
                <div class="flex justify-between items-center p-4 border-b">
                    <h3 id="day-modal-title" class="text-xl font-bold"></h3>
                    <button id="day-modal-close-btn" class="text-gray-500 hover:text-gray-800">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16"><path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/></svg>
                    </button>
                </div>
                <div id="day-modal-content" class="p-6 overflow-y-auto space-y-3">
                    <!-- Topic details will be injected here -->
                </div>
            </div>
        </div>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getFirestore, doc, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCKXzSmQ9F1M4W59Vyalu3CWdKFsh7dOmE",
            authDomain: "costas-304b9.firebaseapp.com",
            projectId: "costas-304b9",
            storageBucket: "costas-304b9.appspot.com",
            messagingSenderId: "251850800414",
            appId: "1:251850800414:web:435e20e5305881732e5d0f",
            measurementId: "G-C2NTL72PZH"
        };
        let db, sessionId;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-planner-app';

        const BLOCKS_CONFIG = {
            "Organización y Funcionamiento de la Administración Pública": { color: "#b45309", icon: "fa-gavel", c: "color-adm" },
            "A.1) Aguas y Obras Hidráulicas": { color: "#0369a1", icon: "fa-tint", c: "color-aguas" },
            "A.2) Puertos y Costas": { color: "#0e7490", icon: "fa-water", c: "color-costas" },
            "B.1) Carreteras": { color: "#4b5563", icon: "fa-road", c: "color-infra" },
            "B.2) Ferrocarriles": { color: "#4b5563", icon: "fa-train", c: "color-infra" },
            "C.1) Transportes y Movilidad": { color: "#059669", icon: "fa-bus", c: "color-trans" },
            "C.2) Medio Ambiente": { color: "#15803d", icon: "fa-leaf", c: "color-ma" }
        };

        const SHORT_NAMES = {
            "Organización y Funcionamiento de la Administración Pública": "Administrativo",
            "A.1) Aguas y Obras Hidráulicas": "Aguas",
            "A.2) Puertos y Costas": "Costas",
            "B.1) Carreteras": "Carreteras",
            "B.2) Ferrocarriles": "Ferrocarriles",
            "C.1) Transportes y Movilidad": "Transportes",
            "C.2) Medio Ambiente": "MA"
        };

        const fullSyllabus = {
            "Materias comunes": { "Organización y Funcionamiento de la Administración Pública": Array.from({length: 17}, (_, i) => ({id: i + 1, text: `Tema Común ${i+1}`}))},
            "Materias específicas": {
                "A) Aguas y Obras Hidráulicas, Puertos y Costas": { "A.1) Aguas y Obras Hidráulicas": Array.from({length: 28}, (_, i) => ({id: i + 1, text: `Tema A.1.${i+1}`})), "A.2) Puertos y Costas": Array.from({length: 20}, (_, i) => ({id: i + 1, text: `Tema A.2.${i+1}`}))},
                "B) Infraestructuras de Transporte": { "B.1) Carreteras": Array.from({length: 24}, (_, i) => ({id: i + 1, text: `Tema B.1.${i+1}`})), "B.2) Ferrocarriles": Array.from({length: 22}, (_, i) => ({id: i + 1, text: `Tema B.2.${i+1}`}))},
                "C) Transportes, Movilidad y Medio Ambiente": { "C.1) Transportes y Movilidad": Array.from({length: 21}, (_, i) => ({id: i + 1, text: `Tema C.1.${i+1}`})), "C.2) Medio Ambiente": Array.from({length: 15}, (_, i) => ({id: i + 1, text: `Tema C.2.${i+1}`}))}
            }
        };

        const ROUND_COLORS = {
            bg: ['bg-red-100', 'bg-orange-100', 'bg-yellow-100', 'bg-blue-100', 'bg-green-100'],
            text: ['text-red-800', 'text-orange-800', 'text-yellow-800', 'text-blue-800', 'text-green-800']
        };

        const endDateInput = document.getElementById('end-date');
        const generateBtn = document.getElementById('generate-btn');
        const saveBtn = document.getElementById('save-btn');
        const saveStatus = document.getElementById('save-status');
        const calendarContainer = document.getElementById('calendar-container');
        const topicSourceList = document.getElementById('topic-source-list');
        const topicSearchInput = document.getElementById('topic-search');
        const roundTabsContainer = document.getElementById('round-tabs');
        const subBlockFilterContainer = document.getElementById('sub-block-filter-container');
        const prevMonthBtn = document.getElementById('prev-month-btn');
        const nextMonthBtn = document.getElementById('next-month-btn');
        const calendarTitle = document.getElementById('calendar-title');
        const summaryPanel = document.getElementById('summary-panel');
        const summaryHeader = document.getElementById('summary-header');
        const summaryContent = document.getElementById('summary-content');
        const summaryRoundSelect = document.getElementById('summary-round-select');
        const summaryTableContainer = document.getElementById('summary-table-container');
        const exportCsvBtn = document.getElementById('export-csv-btn');
        const importCsvInput = document.getElementById('import-csv-input');
        const topicsPanel = document.getElementById('topics-panel');
        const topicsHeader = document.getElementById('topics-header');
        const topicsContent = document.getElementById('topics-content');
        const dayModalBackdrop = document.getElementById('day-modal-backdrop');
        const dayModalContainer = document.getElementById('day-modal-container');
        const dayModalTitle = document.getElementById('day-modal-title');
        const dayModalContent = document.getElementById('day-modal-content');
        const dayModalCloseBtn = document.getElementById('day-modal-close-btn');
        const toggleConfigBtn = document.getElementById('toggle-config-btn');
        const configPanel = document.getElementById('config-panel');
        const viewRoundsBtn = document.getElementById('view-rounds-btn');
        const countdownContainer = document.getElementById('countdown-container');

        let state = {
            flatTopics: [],
            subBlocks: [],
            mainBlocks: {},
            rounds: [],
            topicState: {},
            dayTypes: {}, 
            dayNotes: {},
            selectedTopics: [],
            currentVuelta: 'vuelta-1',
            currentSubBlock: 'todos',
            currentSummaryVuelta: 'vuelta-1',
            displayDate: new Date(),
            draggedTopic: null 
        };

        function initialize() {
            if (Object.keys(firebaseConfig).length > 0) {
                try {
                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                } catch (e) {
                    console.error("Error initializing Firebase:", e);
                    alert("No se pudo inicializar Firebase. Comprueba la configuración.");
                }
            } else {
                console.warn("Firebase config is empty. Persistence is disabled.");
            }

            document.getElementById('login-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const username = document.getElementById('username-input').value.trim();
                if(username) {
                    startApp(username);
                }
            });
        }

        async function startApp(username) {
            sessionId = username;
            document.getElementById('login-modal').style.display = 'none';
            document.getElementById('main-content').classList.remove('hidden');
            
            parseSyllabus();
            setupRoundDurationInputs();
            await loadStateFromFirebase();

            generateBtn.addEventListener('click', generateNewPlan);
            saveBtn.addEventListener('click', saveStateToFirebase);
            topicSearchInput.addEventListener('input', () => renderTopicSourceList());
            prevMonthBtn.addEventListener('click', () => changeMonth(-1));
            nextMonthBtn.addEventListener('click', () => changeMonth(1));
            endDateInput.addEventListener('change', updateCountdown);
            
            topicSourceList.addEventListener('dragover', handleDragOver);
            topicSourceList.addEventListener('dragleave', handleDragLeave);
            topicSourceList.addEventListener('drop', handleDropOnSourceList);
            
            document.addEventListener('dragend', handleDragEnd);
            
            summaryHeader.addEventListener('click', () => {
                summaryContent.classList.toggle('hidden');
                summaryPanel.classList.toggle('collapsed');
            });
            topicsHeader.addEventListener('click', () => {
                topicsPanel.classList.toggle('collapsed');
            });
            summaryRoundSelect.addEventListener('change', (e) => {
                state.currentSummaryVuelta = e.target.value;
                renderSummaryTable();
            });

            exportCsvBtn.addEventListener('click', exportToCSV);
            importCsvInput.addEventListener('change', importFromCSV);
            
            dayModalCloseBtn.addEventListener('click', hideExpandedDayView);
            dayModalBackdrop.addEventListener('click', (e) => {
                if (e.target === dayModalBackdrop) {
                    hideExpandedDayView();
                }
            });
            toggleConfigBtn.addEventListener('click', () => {
                configPanel.classList.toggle('expanded');
            });
            viewRoundsBtn.addEventListener('click', () => {
                window.open(`seguimiento.html?user=${sessionId}`, '_blank');
            });

            renderAll();
        }

        function setupRoundDurationInputs() {
            const roundDurationsContainer = document.getElementById('round-durations-container');
            roundDurationsContainer.innerHTML = ''; // Clear previous
            const defaultDurations = [48, 24, 12, 6, 3]; 
            for (let i = 1; i <= 5; i++) {
                const div = document.createElement('div');
                div.className = 'flex-shrink-0';
                const label = document.createElement('label');
                label.htmlFor = `round-${i}-duration`;
                label.className = 'block text-xs font-medium text-gray-600 mb-1 text-center';
                label.textContent = `Vuelta ${i}`;
                
                const input = document.createElement('input');
                input.type = 'number';
                input.id = `round-${i}-duration`;
                input.min = '1';
                input.value = defaultDurations[i-1];
                input.className = 'w-20 p-2 border border-gray-300 rounded-lg shadow-sm text-center';
                
                div.appendChild(label);
                div.appendChild(input);
                roundDurationsContainer.appendChild(div);
            }
        }

        async function saveStateToFirebase() {
            if (!db || !sessionId) return;
            saveStatus.textContent = "Guardando...";
            saveStatus.className = "text-center text-sm font-medium text-blue-600";
            try {
                const docRef = doc(db, `artifacts/${appId}/public/data/${sessionId}/plannerState`);
                const roundDurations = [];
                for (let i = 1; i <= 5; i++) {
                    roundDurations.push(document.getElementById(`round-${i}-duration`).value);
                }
                const dataToSave = {
                    topicState: state.topicState,
                    dayTypes: state.dayTypes,
                    dayNotes: state.dayNotes,
                    endDate: endDateInput.value,
                    roundDurations: roundDurations
                };
                await setDoc(docRef, dataToSave);
                saveStatus.textContent = "¡Progreso guardado!";
                saveStatus.className = "text-center text-sm font-medium text-green-600";
            } catch (error) {
                console.error("Error saving to Firebase:", error);
                saveStatus.textContent = "Error al guardar.";
                saveStatus.className = "text-center text-sm font-medium text-red-600";
            } finally {
                setTimeout(() => saveStatus.textContent = "", 3000);
            }
        }

        async function loadStateFromFirebase() {
            if (!db || !sessionId) {
                resetTopicState();
                return;
            };
            const docRef = doc(db, `artifacts/${appId}/public/data/${sessionId}/plannerState`);
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (data.endDate) {
                        endDateInput.value = data.endDate;
                    }
                    if (data.roundDurations && data.roundDurations.length === 5) {
                        for (let i = 1; i <= 5; i++) {
                            const input = document.getElementById(`round-${i}-duration`);
                            if(input) input.value = data.roundDurations[i-1];
                        }
                    }
                    if (data.topicState) {
                        state.topicState = data.topicState;
                        if (!state.topicState.studiedTopics) {
                            state.topicState.studiedTopics = {};
                        }
                    } else {
                         resetTopicState();
                    }
                    state.dayTypes = data.dayTypes || {};
                    state.dayNotes = data.dayNotes || {};
                } else {
                    console.log("No previous state found, starting fresh.");
                    resetTopicState();
                }
            } catch (error) {
                console.error("Error loading from Firebase:", error);
                resetTopicState();
            }
        }

        function parseSyllabus() {
            const subBlockSet = new Set();
            state.flatTopics = [];
            state.mainBlocks = {};

            for (const topLevelTitle in fullSyllabus) {
                const mainBlocks = fullSyllabus[topLevelTitle];
                for (const mainBlockTitle in mainBlocks) {
                    const subBlocksOrTopics = mainBlocks[mainBlockTitle];
                    if (Array.isArray(subBlocksOrTopics)) {
                        const blockName = mainBlockTitle;
                        subBlockSet.add(blockName);
                        state.mainBlocks[blockName] = topLevelTitle;
                        subBlocksOrTopics.forEach(topic => state.flatTopics.push({ ...topic, fullId: `${blockName}-${topic.id}`, block: blockName }));
                    } else {
                        for (const subBlockTitle in subBlocksOrTopics) {
                            const blockName = subBlockTitle;
                            subBlockSet.add(blockName);
                            state.mainBlocks[blockName] = mainBlockTitle;
                            subBlocksOrTopics[subBlockTitle].forEach(topic => state.flatTopics.push({ ...topic, fullId: `${blockName}-${topic.id}`, block: blockName }));
                        }
                    }
                }
            }
            state.subBlocks = Array.from(subBlockSet).sort();
        }
        
        function generateNewPlan() {
            renderAll();
        }

        function renderAll() {
            calculateRounds();
            reconcileAssignments();
            if (state.rounds.length > 0 && !state.displayDate) {
                 const planStartDate = state.rounds[0].startDate;
                 state.displayDate = new Date(Date.UTC(planStartDate.getUTCFullYear(), planStartDate.getUTCMonth(), 1));
            }
            updateCountdown();
            renderSummaryRoundSelect();
            renderSummaryTable();
            renderRoundTabs();
            renderSubBlockFilter();
            renderTopicSourceList();
            renderCalendar();
        }

        function updateCountdown() {
            if (!countdownContainer) return;

            const endDateStr = endDateInput.value;
            const endDate = parseDateString(endDateStr);

            if (!endDate) {
                countdownContainer.innerHTML = '';
                return;
            }

            const today = new Date();
            const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));
            const timeDiff = endDate.getTime() - todayUTC.getTime();
            const daysRemaining = Math.ceil(timeDiff / (1000 * 3600 * 24));

            if (daysRemaining < 0) {
                countdownContainer.innerHTML = `
                    <div class="text-sm font-semibold text-red-600">
                        <i class="fas fa-exclamation-triangle mr-1"></i>
                        Fecha Límite Pasada
                    </div>`;
            } else if (daysRemaining === 0) {
                 countdownContainer.innerHTML = `
                    <div class="text-lg font-bold text-blue-600 animate-pulse">
                        <i class="fas fa-flag-checkered mr-2"></i>
                        ¡Es Hoy!
                    </div>`;
            } else {
                countdownContainer.innerHTML = `
                    <div class="text-sm text-gray-500">Días Restantes</div>
                    <div class="text-2xl font-bold text-gray-800">${daysRemaining}</div>
                `;
            }
        }

        function resetTopicState() {
            state.topicState = {
                studiedTopics: {}
            };
            state.dayTypes = {};
            state.dayNotes = {};
            const allTopicIds = state.flatTopics.map(t => t.fullId);
            for (let i = 1; i <= 5; i++) {
                state.topicState[`vuelta-${i}`] = {
                    unassigned: [...allTopicIds],
                    assigned: {} 
                };
            }
        }
        
        function parseDateString(dateStr) {
            const parts = dateStr.match(/^(\d{1,2})[/\-.](\d{1,2})[/\-.](\d{4})$/);
            if (!parts) return null;
            const day = parseInt(parts[1], 10);
            const month = parseInt(parts[2], 10);
            const year = parseInt(parts[3], 10);
            if (day > 31 || month > 12 || year < 1970) return null;
            return new Date(Date.UTC(year, month - 1, day));
        }

        function calculateRounds() {
            const deadline = parseDateString(endDateInput.value);
            const durations = [];
            for (let i = 1; i <= 5; i++) {
                const input = document.getElementById(`round-${i}-duration`);
                const duration = parseInt(input.value, 10);
                if (isNaN(duration) || duration < 1) {
                    state.rounds = [];
                    console.error(`Invalid duration for round ${i}`);
                    return;
                }
                durations.push(duration);
            }

            if (!deadline) {
                state.rounds = [];
                return;
            }

            const totalDuration = durations.reduce((sum, d) => sum + d, 0);

            let planStartDate = new Date(deadline.getTime());
            planStartDate.setUTCDate(planStartDate.getUTCDate() - totalDuration + 1);

            const newRounds = [];
            let currentStartDate = new Date(planStartDate.getTime());

            for (let i = 0; i < 5; i++) {
                const duration = durations[i];
                const roundEndDate = new Date(currentStartDate.getTime());
                roundEndDate.setUTCDate(roundEndDate.getUTCDate() + duration - 1);
                
                newRounds.push({
                    roundNumber: i + 1,
                    vueltaId: `vuelta-${i + 1}`,
                    startDate: new Date(currentStartDate.getTime()),
                    endDate: roundEndDate,
                    duration: duration
                });
                
                currentStartDate = new Date(roundEndDate.getTime());
                currentStartDate.setUTCDate(currentStartDate.getUTCDate() + 1);
            }
            state.rounds = newRounds;
        }

        function reconcileAssignments() {
            if (!state.rounds || state.rounds.length === 0) return;

            for (const round of state.rounds) {
                const roundState = state.topicState[round.vueltaId];
                if (!roundState || !roundState.assigned) continue;

                const lastDayIndex = round.duration - 1;
                const assignedIndices = Object.keys(roundState.assigned).map(Number);

                for (const dayIndex of assignedIndices) {
                    if (dayIndex > lastDayIndex) {
                        const overflowedTopics = roundState.assigned[dayIndex];
                        if (!roundState.assigned[lastDayIndex]) {
                            roundState.assigned[lastDayIndex] = [];
                        }
                        roundState.assigned[lastDayIndex].push(...overflowedTopics);
                        delete roundState.assigned[dayIndex];
                        console.log(`Moved ${overflowedTopics.length} topics from overflowed day ${dayIndex} to last valid day ${lastDayIndex} in ${round.vueltaId}`);
                    }
                }
            }
        }
        
        function renderSummaryRoundSelect() {
            summaryRoundSelect.innerHTML = '';
            for (let i = 1; i <= 5; i++) {
                const option = document.createElement('option');
                option.value = `vuelta-${i}`;
                option.textContent = `Vuelta ${i}`;
                summaryRoundSelect.appendChild(option);
            }
            summaryRoundSelect.value = state.currentSummaryVuelta;
        }
        
        function calculateSummary() {
            const summary = {};
            const roundState = state.topicState[state.currentSummaryVuelta];
            if (!roundState) return {};

            const assignedInRound = Object.values(roundState.assigned).flat();
            const studiedInRound = Object.values(state.topicState.studiedTopics)
                .flat()
                .filter(t => t.originalVuelta === state.currentSummaryVuelta);
            
            const allAssignedTopics = [...assignedInRound, ...studiedInRound];

            state.subBlocks.forEach(subBlock => {
                const mainBlock = state.mainBlocks[subBlock];
                if (!summary[mainBlock]) {
                    summary[mainBlock] = {};
                }
                
                const topicsInSubBlock = state.flatTopics.filter(t => t.block === subBlock);
                const assignedInSubBlock = allAssignedTopics.filter(assignedTopic => topicsInSubBlock.some(t => t.fullId === assignedTopic.id));
                const studiedInSubBlock = assignedInSubBlock.filter(t => t.studied).length;

                summary[mainBlock][subBlock] = {
                    total: topicsInSubBlock.length,
                    asignados: assignedInSubBlock.length,
                    estudiados: studiedInSubBlock,
                    pendientes: assignedInSubBlock.length - studiedInSubBlock
                };
            });
            return summary;
        }

        function renderSummaryTable() {
            const summaryData = calculateSummary();
            let tableHTML = `<table class="w-full text-sm text-left text-gray-700">
                <thead class="text-xs text-gray-700 uppercase bg-gray-100">
                    <tr>
                        <th class="px-4 py-3">Bloque</th>
                        <th class="px-4 py-3">Sub-bloque</th>
                        <th class="px-4 py-3 text-center">Asignados</th>
                        <th class="px-4 py-3 text-center">Estudiados</th>
                        <th class="px-4 py-3 text-center">Pendientes</th>
                        <th class="px-4 py-3 text-center">Total</th>
                    </tr>
                </thead><tbody>`;
            
            let grandTotal = { total: 0, asignados: 0, estudiados: 0, pendientes: 0 };

            for (const mainBlock in summaryData) {
                const subBlocks = summaryData[mainBlock];
                const subBlockKeys = Object.keys(subBlocks);
                let blockTotal = { total: 0, asignados: 0, estudiados: 0, pendientes: 0 };

                subBlockKeys.forEach((subBlock, index) => {
                    const data = subBlocks[subBlock];
                    const config = BLOCKS_CONFIG[subBlock] || {};
                    blockTotal.total += data.total;
                    blockTotal.asignados += data.asignados;
                    blockTotal.estudiados += data.estudiados;
                    blockTotal.pendientes += data.pendientes;

                    tableHTML += `<tr class="border-b">
                        ${index === 0 ? `<td class="px-4 py-4 font-semibold align-top" rowspan="${subBlockKeys.length}">${mainBlock}</td>` : ''}
                        <td class="px-4 py-4 font-semibold ${config.c || ''}"><i class="fas ${config.icon || ''} fa-fw w-5"></i> ${SHORT_NAMES[subBlock] || subBlock}</td>
                        <td class="px-4 py-4 text-center">${data.asignados}</td>
                        <td class="px-4 py-4 text-center">${data.estudiados}</td>
                        <td class="px-4 py-4 text-center">${data.pendientes}</td>
                        <td class="px-4 py-4 text-center">${data.total}</td>
                    </tr>`;
                });
                
                grandTotal.total += blockTotal.total;
                grandTotal.asignados += blockTotal.asignados;
                grandTotal.estudiados += blockTotal.estudiados;
                grandTotal.pendientes += blockTotal.pendientes;

                tableHTML += `<tr class="bg-gray-50 font-semibold border-b-4 border-white">
                    <td class="px-4 py-2 text-right" colspan="2">Total Bloque:</td>
                    <td class="px-4 py-2 text-center">${blockTotal.asignados}</td>
                    <td class="px-4 py-2 text-center">${blockTotal.estudiados}</td>
                    <td class="px-4 py-2 text-center">${blockTotal.pendientes}</td>
                    <td class="px-4 py-2 text-center">${blockTotal.total}</td>
                </tr>`;
            }
            
            tableHTML += `</tbody><tfoot class="bg-indigo-100 font-bold text-indigo-800">
                <tr>
                    <td class="px-4 py-3 text-right" colspan="2">TOTAL GENERAL:</td>
                    <td class="px-4 py-3 text-center">${grandTotal.asignados}</td>
                    <td class="px-4 py-3 text-center">${grandTotal.estudiados}</td>
                    <td class="px-4 py-3 text-center">${grandTotal.pendientes}</td>
                    <td class="px-4 py-3 text-center">${grandTotal.total}</td>
                </tr>
            </tfoot></table>`;
            
            summaryTableContainer.innerHTML = tableHTML;
        }
        
        function renderRoundTabs() {
            roundTabsContainer.innerHTML = '';
            for (let i = 1; i <= 5; i++) {
                const vueltaId = `vuelta-${i}`;
                const tab = document.createElement('button');
                tab.textContent = `V${i}`;
                const colorClass = ROUND_COLORS.text[i-1] || 'text-gray-500';
                tab.className = `px-3 py-2 text-sm font-medium border-b-2 -mb-px ${state.currentVuelta === vueltaId ? 'border-indigo-500 text-indigo-600' : `border-transparent ${colorClass.replace('text-', 'hover:text-')} hover:border-gray-300`}`;
                tab.onclick = () => {
                    state.currentVuelta = vueltaId;
                    renderRoundTabs();
                    renderTopicSourceList();
                };
                roundTabsContainer.appendChild(tab);
            }
        }

        function renderSubBlockFilter() {
            subBlockFilterContainer.innerHTML = '';
            const select = document.createElement('select');
            select.className = 'w-full p-2 border border-gray-300 rounded-lg text-sm';
            select.innerHTML = `<option value="todos">Todos los Bloques</option>`;
            state.subBlocks.forEach(block => {
                const displayName = SHORT_NAMES[block] || block;
                select.innerHTML += `<option value="${block}">${displayName}</option>`;
            });
            select.value = state.currentSubBlock;
            select.onchange = (e) => {
                state.currentSubBlock = e.target.value;
                renderTopicSourceList();
            };
            subBlockFilterContainer.appendChild(select);
        }

        function findTopicGlobalAssignment(topicId) {
            // Check studied topics first, as it's a more definitive state
            for (const dateStr in state.topicState.studiedTopics) {
                const topic = state.topicState.studiedTopics[dateStr].find(t => t.id === topicId);
                if (topic) {
                    return { status: 'studied', date: dateStr, originalVuelta: topic.originalVuelta };
                }
            }
            // Check assigned (not yet studied) topics
            for (const vueltaId in state.topicState) {
                if (vueltaId === 'studiedTopics' || !state.topicState[vueltaId].assigned) continue;
                const roundState = state.topicState[vueltaId];
                for (const dayIndex in roundState.assigned) {
                    const topic = roundState.assigned[dayIndex].find(t => t.id === topicId);
                    if (topic) {
                        const roundInfo = state.rounds.find(r => r.vueltaId === vueltaId);
                        if (roundInfo) {
                            const date = new Date(roundInfo.startDate);
                            date.setUTCDate(date.getUTCDate() + parseInt(dayIndex, 10));
                            return { status: 'assigned', date: date.toISOString().split('T')[0], vueltaId: vueltaId };
                        }
                    }
                }
            }
            return { status: 'unassigned' };
        }
        
        function getTopicStatusForVuelta(topicId, vueltaId) {
            // Is it studied from this vuelta?
            for (const dateStr in state.topicState.studiedTopics) {
                const topic = state.topicState.studiedTopics[dateStr].find(t => t.id === topicId && t.originalVuelta === vueltaId);
                if (topic) {
                    return { status: 'studied' };
                }
            }

            // Is it assigned in this vuelta?
            const roundState = state.topicState[vueltaId];
            if (roundState && roundState.assigned) {
                for (const dayIndex in roundState.assigned) {
                    const topic = roundState.assigned[dayIndex].find(t => t.id === topicId);
                    if (topic) {
                        return { status: 'assigned' };
                    }
                }
            }

            // Is it unassigned in this vuelta?
            if(roundState && roundState.unassigned.includes(topicId)) {
                return { status: 'unassigned' };
            }
            
            return { status: 'other' }; 
        }

        function wasTopicStudiedInVuelta(topicId, vueltaId) {
            if (!vueltaId) return false;
            for (const dateStr in state.topicState.studiedTopics) {
                const topic = state.topicState.studiedTopics[dateStr].find(t => t.id === topicId && t.originalVuelta === vueltaId);
                if (topic) {
                    return true;
                }
            }
            return false;
        }

        /**
         * [FIXED] This function is now scoped to only remove a topic from the specified round,
         * preventing data loss in other rounds.
         * @param {string} topicId - The full ID of the topic to unassign.
         * @param {string} vueltaIdToReturnTo - The ID of the round to remove the topic from.
         */
        function unassignTopic(topicId, vueltaIdToReturnTo) {
            const roundState = state.topicState[vueltaIdToReturnTo];
            if (!roundState) {
                console.error(`Cannot unassign topic: round state for ${vueltaIdToReturnTo} does not exist.`);
                return;
            }
            
            let originalDate = null;

            // 1. Check if it's 'assigned' (but not studied) in this round and remove it.
            const roundInfo = state.rounds.find(r => r.vueltaId === vueltaIdToReturnTo);
            if (roundState.assigned && roundInfo) {
                for (const dayIndex in roundState.assigned) {
                    const dayTopics = roundState.assigned[dayIndex];
                    const topicIndex = dayTopics.findIndex(t => t.id === topicId);
                    if (topicIndex > -1) {
                        // Found it. Remove from assigned.
                        dayTopics.splice(topicIndex, 1);
                        if (dayTopics.length === 0) delete roundState.assigned[dayIndex];

                        // Save date for UI update
                        const date = new Date(roundInfo.startDate);
                        date.setUTCDate(date.getUTCDate() + parseInt(dayIndex, 10));
                        originalDate = date.toISOString().split('T')[0];
                        
                        // Break the loop once found and removed
                        break; 
                    }
                }
            }

            // 2. If not found in 'assigned', check if it was 'studied' *from this specific round*.
            if (!originalDate) { // Only check 'studied' if not found in 'assigned'
                for (const dateStr in state.topicState.studiedTopics) {
                    const dayTopics = state.topicState.studiedTopics[dateStr];
                    const topicIndex = dayTopics.findIndex(t => t.id === topicId && t.originalVuelta === vueltaIdToReturnTo);
                    if (topicIndex > -1) {
                        // Found it. Remove from studied.
                        dayTopics.splice(topicIndex, 1);
                        if (dayTopics.length === 0) delete state.topicState.studiedTopics[dateStr];
                        
                        // Save date for UI update
                        originalDate = dateStr;
                        
                        // Break the loop once found and removed
                        break;
                    }
                }
            }
            
            // 3. If the topic was found and removed from either list, add it back to unassigned.
            if (originalDate) {
                if (!roundState.unassigned.includes(topicId)) {
                    roundState.unassigned.push(topicId);
                    roundState.unassigned.sort(); // Keep it tidy
                }
                
                // 4. Update UI
                updateSingleDay(originalDate);
                renderTopicSourceList();
                renderSummaryTable();
            } else {
                console.warn(`Attempted to unassign topic ${topicId} from ${vueltaIdToReturnTo}, but it was not found as either assigned or studied in that specific round.`);
            }
        }

        function renderTopicSourceList() {
            if (!state.topicState[state.currentVuelta]) return;

            topicSourceList.innerHTML = '';
            const searchTerm = topicSearchInput.value.toLowerCase();
            
            let topicsToDisplay = [...state.flatTopics];

            if (state.currentSubBlock !== 'todos') {
                topicsToDisplay = topicsToDisplay.filter(topic => topic.block === state.currentSubBlock);
            }

            if (searchTerm) {
                topicsToDisplay = topicsToDisplay.filter(topic => 
                    topic.text.toLowerCase().includes(searchTerm) || 
                    topic.block.toLowerCase().includes(searchTerm) ||
                    (SHORT_NAMES[topic.block] && SHORT_NAMES[topic.block].toLowerCase().includes(searchTerm))
                );
            }

            topicsToDisplay.sort((a, b) => a.block.localeCompare(b.block) || a.id - b.id);

            topicsToDisplay.forEach(topic => {
                const topicId = topic.fullId;
                const statusInCurrentVuelta = getTopicStatusForVuelta(topicId, state.currentVuelta);

                if (statusInCurrentVuelta.status === 'assigned' || statusInCurrentVuelta.status === 'studied') {
                    const el = document.createElement('div');
                    el.className = 'topic-card unavailable bg-gray-50 p-2 rounded-lg mb-2 flex items-center justify-between';
                    el.style.cursor = 'pointer';
                    el.title = 'Haz clic para ver en el calendario';
                    
                    const color = BLOCKS_CONFIG[topic.block]?.color || '#6b7280';
                    const displayName = SHORT_NAMES[topic.block] || topic.block;
                    
                    let statusIcon;
                    if (statusInCurrentVuelta.status === 'studied') {
                        statusIcon = `<i class="fas fa-check-circle text-green-500 mr-2" title="Estudiado en esta vuelta"></i>`;
                    } else {
                        statusIcon = `<i class="fas fa-check-circle text-orange-400 mr-2" title="Asignado en esta vuelta"></i>`;
                    }

                    el.innerHTML = `
                        <div class="flex items-center overflow-hidden">
                            ${statusIcon}
                            <div class="w-2 h-2 rounded-full flex-shrink-0 mr-2" style="background-color: ${color};"></div>
                            <span class="text-sm font-medium truncate">${displayName} - T${topic.id}</span>
                        </div>
                        <button title="Desasignar Tema" class="unassign-btn flex-shrink-0 ml-2">
                            <i class="fas fa-times-circle"></i>
                        </button>
                    `;
                    
                    el.addEventListener('click', (e) => {
                        if (!e.target.closest('.unassign-btn')) {
                            navigateToTopicDate(topicId, state.currentVuelta);
                        }
                    });

                    el.querySelector('.unassign-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        unassignTopic(topicId, state.currentVuelta);
                    });
                    topicSourceList.appendChild(el);

                } else if (statusInCurrentVuelta.status === 'unassigned') {
                    const el = document.createElement('div');
                    el.className = 'topic-card bg-gray-100 p-2 rounded-lg mb-2 flex items-center justify-between';
                    el.draggable = true;
                    el.dataset.topicId = topicId;

                    if (state.selectedTopics.includes(topicId)) {
                        el.classList.add('selected');
                    }

                    el.addEventListener('click', (e) => {
                        e.preventDefault();
                        const isCtrlOrMeta = e.ctrlKey || e.metaKey;
                        
                        if (!isCtrlOrMeta) {
                            document.querySelectorAll('#topic-source-list .topic-card.selected').forEach(card => card.classList.remove('selected'));
                            state.selectedTopics = [topicId];
                            el.classList.add('selected');
                        } else {
                            if (state.selectedTopics.includes(topicId)) {
                                state.selectedTopics = state.selectedTopics.filter(id => id !== topicId);
                                el.classList.remove('selected');
                            } else {
                                state.selectedTopics.push(topicId);
                                el.classList.add('selected');
                            }
                        }
                    });

                    const currentRoundNumber = parseInt(state.currentVuelta.split('-')[1], 10);
                    let needsReview = false;
                    if (currentRoundNumber > 1) {
                        const previousVueltaId = `vuelta-${currentRoundNumber - 1}`;
                        if (wasTopicStudiedInVuelta(topicId, previousVueltaId)) {
                            needsReview = true;
                        }
                    }

                    if (needsReview) {
                        el.classList.add('needs-review');
                    }

                    const color = BLOCKS_CONFIG[topic.block]?.color || '#6b7280';
                    const displayName = SHORT_NAMES[topic.block] || topic.block;
                    let reviewIconHTML = '';
                    if (needsReview) {
                        reviewIconHTML = `<i class="fas fa-star text-yellow-500" title="Estudiado en la vuelta anterior"></i>`;
                    }

                    el.innerHTML = `
                        <div class="flex items-center gap-2 overflow-hidden">
                            <div class="w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${color};"></div>
                            <span class="text-sm font-medium truncate">${displayName} - T${topic.id}</span>
                        </div>
                        <div class="flex-shrink-0">${reviewIconHTML}</div>
                    `;
                    el.addEventListener('dragstart', handleDragStartFromSource);
                    topicSourceList.appendChild(el);
                }
            });
        }

        function renderCalendar() {
            calendarContainer.innerHTML = '';
            const year = state.displayDate.getUTCFullYear();
            const month = state.displayDate.getUTCMonth();
            
            calendarTitle.textContent = `${(new Date(Date.UTC(year, month))).toLocaleString('es-ES', {month: 'long', year: 'numeric', timeZone: 'UTC'})}`;

            const monthGridElement = createMonthGrid(year, month);
            calendarContainer.appendChild(monthGridElement);
            updateAllCalendarDaysForMonth(monthGridElement, year, month);
        }

        function getDayType(dateStr) {
            if (state.dayTypes[dateStr]) {
                return state.dayTypes[dateStr];
            }
            const day = new Date(dateStr + 'T00:00:00Z').getUTCDay();
            // 0=Sun, 1=Mon, ..., 6=Sat
            return (day === 0 || day === 6) ? 'vacation' : 'work';
        }

        function updateDayAppearance(dayCell) {
            const dateStr = dayCell.dataset.date;
            const dayDate = new Date(dateStr + 'T00:00:00Z');
            const round = state.rounds.find(r => dayDate >= r.startDate && dayDate <= r.endDate);
            const dayType = getDayType(dateStr);

            const roundLabel = dayCell.querySelector('.day-round-label');
            const noteIcon = dayCell.querySelector('.note-icon');
            
            // Reset
            dayCell.style.background = '';
            roundLabel.textContent = '';
            roundLabel.className = 'day-round-label text-xs font-bold text-center pb-1';

            if (round) {
                const roundBgClass = ROUND_COLORS.bg[round.roundNumber - 1];
                const roundTextClass = ROUND_COLORS.text[round.roundNumber - 1];
                const roundColorMap = { 'bg-red-100': '#fee2e2', 'bg-orange-100': '#ffedd5', 'bg-yellow-100': '#fef9c3', 'bg-blue-100': '#dbeafe', 'bg-green-100': '#dcfce7' };
                const roundBgColor = roundColorMap[roundBgClass] || '#f9fafb';
                
                roundLabel.textContent = `Vuelta ${round.roundNumber}`;
                roundLabel.classList.add(roundTextClass);

                if (dayType === 'work') {
                    dayCell.style.background = `linear-gradient(to bottom, #fecaca 25%, ${roundBgColor} 25%)`;
                } else { // vacation
                    dayCell.style.background = roundBgColor;
                }
            } else {
                dayCell.style.background = '#f9fafb'; // bg-gray-50
            }

            if (noteIcon) {
                if (state.dayNotes[dateStr] && state.dayNotes[dateStr].trim() !== '') {
                    noteIcon.classList.remove('hidden');
                } else {
                    noteIcon.classList.add('hidden');
                }
            }
        }

        function createMonthGrid(year, month) {
            const monthContainer = document.createElement('div');
            const firstDayOfMonth = new Date(Date.UTC(year, month, 1));
            const daysInMonth = new Date(Date.UTC(year, month + 1, 0)).getUTCDate();

            const grid = document.createElement('div');
            grid.className = 'grid grid-cols-7 gap-1';
            
            ['L', 'M', 'X', 'J', 'V', 'S', 'D'].forEach(day => {
                grid.innerHTML += `<div class="text-center font-semibold text-sm text-gray-500 pb-2">${day}</div>`;
            });

            const dayOffset = (firstDayOfMonth.getUTCDay() + 6) % 7;
            for (let i = 0; i < dayOffset; i++) {
                grid.appendChild(document.createElement('div'));
            }

            for (let i = 1; i <= daysInMonth; i++) {
                const dayDate = new Date(Date.UTC(year, month, i));
                const dateStr = dayDate.toISOString().split('T')[0];
                const dayCell = document.createElement('div');
                dayCell.className = 'calendar-day border border-gray-200 rounded-lg flex flex-col relative';
                dayCell.dataset.date = dateStr;

                dayCell.innerHTML = `
                    <i class="fas fa-sticky-note text-yellow-500 note-icon hidden absolute top-2 left-2"></i>
                    <div class="day-number text-sm font-bold absolute top-1.5 right-2">${i}</div>
                    <div id="topics-${dateStr}" class="calendar-day-topics flex-grow space-y-1 overflow-y-auto mt-8 p-1.5"></div>
                    <div class="day-round-label text-xs font-bold text-center pb-1"></div>
                `;
                
                updateDayAppearance(dayCell);
                
                dayCell.addEventListener('dragover', handleDragOver);
                dayCell.addEventListener('dragleave', handleDragLeave);
                dayCell.addEventListener('drop', handleDropOnCalendar);
                dayCell.addEventListener('click', (e) => {
                    if (!e.target.closest('.calendar-topic-item')) {
                        showExpandedDayView(dateStr);
                    }
                });
                
                grid.appendChild(dayCell);
            }
            monthContainer.appendChild(grid);
            return monthContainer;
        }
        
        function updateAllCalendarDaysForMonth(container, year, month) {
             for (let i = 1; i <= 31; i++) {
                const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(i).padStart(2, '0')}`;
                const topicsContainer = container.querySelector(`#topics-${dateStr}`);
                if (topicsContainer) {
                    updateSingleDay(dateStr);
                }
            }
        }

        function updateSingleDay(dateStr) {
            const topicsContainer = document.getElementById(`topics-${dateStr}`);
            if (!topicsContainer) return;
            
            topicsContainer.innerHTML = '';
            const dayDate = new Date(dateStr + 'T00:00:00Z');
            const allTopicsForDay = [];

            // Get unstudied, relative topics
            for (const round of state.rounds) {
                if (dayDate >= round.startDate && dayDate <= round.endDate) {
                    const dayIndex = Math.round((dayDate - round.startDate) / (1000 * 60 * 60 * 24));
                    const roundState = state.topicState[round.vueltaId];
                    if (roundState && roundState.assigned[dayIndex]) {
                        const dayTopics = roundState.assigned[dayIndex];
                        dayTopics.forEach(topicData => {
                            const topicInfo = state.flatTopics.find(t => t.fullId === topicData.id);
                            if (topicInfo) {
                                allTopicsForDay.push({ type: 'relative', topicData, topicInfo, vueltaId: round.vueltaId, dayIndex });
                            }
                        });
                    }
                }
            }

            // Get studied, fixed topics
            const studiedTopics = state.topicState.studiedTopics[dateStr];
            if (studiedTopics) {
                studiedTopics.forEach(topicData => {
                    const topicInfo = state.flatTopics.find(t => t.fullId === topicData.id);
                    if (topicInfo) {
                        allTopicsForDay.push({ type: 'fixed', topicData, topicInfo, originalVuelta: topicData.originalVuelta });
                    }
                });
            }

            const topicCount = allTopicsForDay.length;

            if (topicCount > 3) {
                topicsContainer.className = 'calendar-day-topics flex-grow mt-1 overflow-y-auto p-1';
                const gridDiv = document.createElement('div');
                gridDiv.className = 'topics-grid';
                const col1 = document.createElement('div');
                col1.className = 'topics-column';
                const col2 = document.createElement('div');
                col2.className = 'topics-column';
                gridDiv.append(col1, col2);

                allTopicsForDay.forEach((topic, loopIndex) => {
                    const el = createCalendarTopicElement(topic, dateStr, true);
                    if (topicCount > 8 && loopIndex % 2 !== 0) {
                        col2.appendChild(el);
                    } else if (topicCount <= 8 && loopIndex >= Math.ceil(topicCount / 2)) {
                        col2.appendChild(el);
                    } else {
                        col1.appendChild(el);
                    }
                });
                topicsContainer.appendChild(gridDiv);

            } else {
                topicsContainer.className = 'calendar-day-topics flex-grow mt-1 space-y-1 overflow-y-auto p-1';
                allTopicsForDay.forEach((topic) => {
                    const el = createCalendarTopicElement(topic, dateStr, false);
                    topicsContainer.appendChild(el);
                });
            }
        }
        
        function createCalendarTopicElement(topic, dateStr, inGrid = false) {
            const { type, topicData, topicInfo } = topic;
            const vueltaId = type === 'relative' ? topic.vueltaId : topic.originalVuelta;
            
            const el = document.createElement('div');
            el.className = `calendar-topic-item p-1 rounded bg-white/80 shadow-sm flex items-center ${inGrid ? 'in-grid' : ''}`;
            el.draggable = true;
            el.dataset.topicId = topicInfo.fullId;
            el.dataset.isStudied = topicData.studied;
            
            if (type === 'relative') {
                el.dataset.sourceVuelta = topic.vueltaId;
                el.dataset.sourceDayIndex = topic.dayIndex;
            } else { // fixed
                el.dataset.sourceDate = dateStr;
                el.dataset.originalVuelta = topic.originalVuelta;
            }
            
            el.addEventListener('dragstart', handleDragStartFromCalendar);

            const color = BLOCKS_CONFIG[topicInfo.block]?.color || '#6b7280';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-checkbox';
            checkbox.checked = topicData.studied;
            checkbox.onclick = (e) => e.stopPropagation();
            checkbox.onchange = () => handleTopicStudiedChange(checkbox.checked, topic, dateStr);

            const label = document.createElement('span');
            label.className = `flex-grow ${topicData.studied ? 'line-through text-gray-400' : ''}`;
            
            if (inGrid) {
                const displayName = SHORT_NAMES[topicInfo.block] || topicInfo.block;
                const abbreviation = displayName.substring(0, 2).toUpperCase();
                label.textContent = `V${vueltaId.slice(-1)}:${abbreviation}T${topicInfo.id}`;
            } else {
                const displayName = SHORT_NAMES[topicInfo.block] || topicInfo.block;
                label.textContent = `V${vueltaId.slice(-1)}: ${displayName} T${topicInfo.id}`;
            }

            const colorDot = document.createElement('div');
            colorDot.className = 'color-dot w-2 h-2 rounded-full flex-shrink-0';
            colorDot.style.backgroundColor = color;

            el.appendChild(colorDot);
            el.appendChild(checkbox);
            el.appendChild(label);
            return el;
        }
        
        function handleSecurityLevelChange(topicId, dateStr, newLevel) {
            const studiedDay = state.topicState.studiedTopics[dateStr];
            if (studiedDay) {
                const topic = studiedDay.find(t => t.id === topicId);
                if (topic) {
                    topic.securityLevel = newLevel;
                }
            }
        }

        function createExpandedCalendarTopicElement(topic, dateStr) {
            const { type, topicData, topicInfo } = topic;
            const vueltaId = type === 'relative' ? topic.vueltaId : topic.originalVuelta;

            const el = document.createElement('div');
            el.className = 'p-3 rounded-lg shadow-sm flex items-center gap-3'; // Base classes

            // Apply background color based on security level
            if (topicData.studied) {
                const securityLevel = topicData.securityLevel || 100;
                el.classList.add(`security-${securityLevel}`);
            } else {
                el.classList.add('bg-gray-100');
            }

            // Security level selector (if studied)
            if (topicData.studied) {
                const securitySelectContainer = document.createElement('div');
                securitySelectContainer.className = 'flex flex-col items-center flex-shrink-0';
                
                const securityLabel = document.createElement('label');
                securityLabel.className = 'text-xs font-bold text-gray-600 mb-1';
                securityLabel.textContent = 'Seg.';

                const securitySelect = document.createElement('select');
                securitySelect.className = 'p-1 border border-gray-400 rounded-md text-xs shadow-sm w-16';
                
                const levels = [20, 40, 60, 80, 100];
                levels.forEach(level => {
                    const option = document.createElement('option');
                    option.value = level;
                    option.textContent = `${level}%`;
                    securitySelect.appendChild(option);
                });

                securitySelect.value = topicData.securityLevel || 100;

                securitySelect.addEventListener('click', e => e.stopPropagation());
                securitySelect.addEventListener('change', (e) => {
                    e.stopPropagation();
                    handleSecurityLevelChange(topicInfo.fullId, dateStr, parseInt(e.target.value, 10));
                    showExpandedDayView(dateStr);
                });
                
                securitySelectContainer.appendChild(securityLabel);
                securitySelectContainer.appendChild(securitySelect);
                el.appendChild(securitySelectContainer);
            }

            const mainContentContainer = document.createElement('div');
            mainContentContainer.className = 'flex items-center gap-3 flex-grow';

            const colorDot = document.createElement('div');
            colorDot.className = 'w-3 h-3 rounded-full flex-shrink-0';
            colorDot.style.backgroundColor = BLOCKS_CONFIG[topicInfo.block]?.color || '#6b7280';
            mainContentContainer.appendChild(colorDot);

            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.className = 'form-checkbox';
            checkbox.checked = topicData.studied;
            checkbox.addEventListener('click', (e) => e.stopPropagation());
            checkbox.addEventListener('change', () => {
                handleTopicStudiedChange(checkbox.checked, topic, dateStr);
                showExpandedDayView(dateStr);
            });
            mainContentContainer.appendChild(checkbox);

            const textContainer = document.createElement('div');
            textContainer.className = 'topic-text-container flex-grow';
            
            const mainLabel = document.createElement('div');
            mainLabel.className = 'font-semibold';
            mainLabel.textContent = topicInfo.text;
            
            const subLabel = document.createElement('div');
            subLabel.className = 'text-sm text-gray-600';
            const displayName = SHORT_NAMES[topicInfo.block] || topicInfo.block;
            subLabel.textContent = `Vuelta ${vueltaId.slice(-1)} | ${displayName}`;

            textContainer.append(mainLabel, subLabel);
            mainContentContainer.appendChild(textContainer);
            el.appendChild(mainContentContainer);

            return el;
        }


        function handleTopicStudiedChange(isStudied, topic, dateStr) {
            const { type, topicData, topicInfo } = topic;

            if (isStudied) {
                // Move from relative to fixed
                if (type === 'relative') {
                    const roundState = state.topicState[topic.vueltaId];
                    const dayTopics = roundState.assigned[topic.dayIndex];
                    const topicIndex = dayTopics.findIndex(t => t.id === topicInfo.fullId);
                    if (topicIndex > -1) {
                        dayTopics.splice(topicIndex, 1);
                        if (dayTopics.length === 0) delete roundState.assigned[topic.dayIndex];
                    }

                    if (!state.topicState.studiedTopics[dateStr]) {
                        state.topicState.studiedTopics[dateStr] = [];
                    }
                    state.topicState.studiedTopics[dateStr].push({
                        id: topicInfo.fullId,
                        studied: true,
                        originalVuelta: topic.vueltaId,
                        securityLevel: 100 // Default security level
                    });
                }
            } else {
                // Move from fixed to relative on the same day
                if (type === 'fixed') {
                    const dayTopics = state.topicState.studiedTopics[dateStr];
                    const topicIndex = dayTopics.findIndex(t => t.id === topicInfo.fullId);
                    if (topicIndex > -1) {
                        const [unstudiedTopic] = dayTopics.splice(topicIndex, 1);
                        if (dayTopics.length === 0) delete state.topicState.studiedTopics[dateStr];

                        const dropDate = new Date(dateStr + 'T00:00:00Z');
                        const targetRound = state.rounds.find(r => dropDate >= r.startDate && dropDate <= r.endDate);

                        if (targetRound) {
                            const targetDayIndex = Math.round((dropDate - targetRound.startDate) / (1000 * 60 * 60 * 24));
                            const targetRoundState = state.topicState[targetRound.vueltaId];
                            if (!targetRoundState.assigned[targetDayIndex]) {
                                targetRoundState.assigned[targetDayIndex] = [];
                            }
                            targetRoundState.assigned[targetDayIndex].push({ id: unstudiedTopic.id, studied: false });
                        } else {
                            const originalRoundState = state.topicState[unstudiedTopic.originalVuelta];
                            if (!originalRoundState.unassigned.includes(unstudiedTopic.id)) {
                                originalRoundState.unassigned.push(unstudiedTopic.id);
                            }
                        }
                    }
                }
            }
            updateSingleDay(dateStr);
            renderTopicSourceList();
            renderSummaryTable();
        }

        function showExpandedDayView(dateStr) {
            const date = new Date(dateStr + 'T00:00:00Z');
            dayModalTitle.textContent = date.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' });
            
            dayModalContent.innerHTML = '';

            const allTopicsForDay = [];
            // Get unstudied, relative topics
            for (const round of state.rounds) {
                if (date >= round.startDate && date <= round.endDate) {
                    const dayIndex = Math.round((date - round.startDate) / (1000 * 60 * 60 * 24));
                    const roundState = state.topicState[round.vueltaId];
                     if (roundState && roundState.assigned[dayIndex]) {
                        const dayTopics = roundState.assigned[dayIndex];
                        dayTopics.forEach(topicData => {
                            const topicInfo = state.flatTopics.find(t => t.fullId === topicData.id);
                            if (topicInfo) {
                                allTopicsForDay.push({ type: 'relative', topicData, topicInfo, vueltaId: round.vueltaId, dayIndex });
                            }
                        });
                    }
                }
            }
            // Get studied, fixed topics
            const studiedTopics = state.topicState.studiedTopics[dateStr];
            if (studiedTopics) {
                studiedTopics.forEach(topicData => {
                    const topicInfo = state.flatTopics.find(t => t.fullId === topicData.id);
                    if (topicInfo) {
                        allTopicsForDay.push({ type: 'fixed', topicData, topicInfo, originalVuelta: topicData.originalVuelta });
                    }
                });
            }


            if (allTopicsForDay.length > 0) {
                allTopicsForDay.forEach((topic) => {
                    const el = createExpandedCalendarTopicElement(topic, dateStr);
                    dayModalContent.appendChild(el);
                });
            } else {
                dayModalContent.innerHTML = '<p class="text-gray-500 text-center">No hay temas asignados para este día.</p>';
            }

            const currentDayType = getDayType(dateStr);
            const dayConfigHTML = `
                <div class="mt-6 pt-4 border-t space-y-4">
                    <div>
                        <label for="day-type-select" class="block text-sm font-medium text-gray-700">Tipo de Día</label>
                        <select id="day-type-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                            <option value="work" ${currentDayType === 'work' ? 'selected' : ''}>Laboral</option>
                            <option value="vacation" ${currentDayType === 'vacation' ? 'selected' : ''}>Vacaciones / Festivo</option>
                        </select>
                    </div>
                    <div>
                        <label for="day-note-textarea" class="block text-sm font-medium text-gray-700">Notas del Día</label>
                        <textarea id="day-note-textarea" rows="3" class="mt-1 block w-full shadow-sm sm:text-sm border-gray-300 rounded-md" placeholder="Añade tus notas aquí..."></textarea>
                    </div>
                </div>
            `;
            dayModalContent.insertAdjacentHTML('beforeend', dayConfigHTML);

            const dayTypeSelect = document.getElementById('day-type-select');
            dayTypeSelect.addEventListener('change', (e) => {
                const newType = e.target.value;
                state.dayTypes[dateStr] = newType;
                const dayCell = document.querySelector(`.calendar-day[data-date="${dateStr}"]`);
                if (dayCell) {
                    updateDayAppearance(dayCell);
                }
            });

            const dayNoteTextarea = document.getElementById('day-note-textarea');
            dayNoteTextarea.value = state.dayNotes[dateStr] || '';
            dayNoteTextarea.addEventListener('input', (e) => {
                const newNote = e.target.value;
                if (newNote && newNote.trim() !== '') {
                    state.dayNotes[dateStr] = newNote;
                } else {
                    delete state.dayNotes[dateStr];
                }
                const dayCell = document.querySelector(`.calendar-day[data-date="${dateStr}"]`);
                if (dayCell) {
                    updateDayAppearance(dayCell);
                }
            });

            dayModalBackdrop.classList.remove('hidden');
            dayModalContainer.classList.remove('hidden');
        }

        function hideExpandedDayView() {
            dayModalBackdrop.classList.add('hidden');
            dayModalContainer.classList.add('hidden');
        }


        function changeMonth(direction) {
            state.displayDate.setUTCMonth(state.displayDate.getUTCMonth() + direction);
            renderCalendar();
        }

        /**
         * Finds a topic's assignment specifically within a given round.
         * @param {string} topicId - The full ID of the topic.
         * @param {string} vueltaId - The ID of the round to search within.
         * @returns {object|null} An object with status and date, or null if not found.
         */
        function findTopicAssignmentInVuelta(topicId, vueltaId) {
            if (!vueltaId) return null;

            // First, check for topics studied that *originated* from this vueltaId
            for (const dateStr in state.topicState.studiedTopics) {
                const topic = state.topicState.studiedTopics[dateStr].find(t => t.id === topicId && t.originalVuelta === vueltaId);
                if (topic) {
                    return { status: 'studied', date: dateStr };
                }
            }

            // Second, check for topics assigned (but not yet studied) in this vueltaId
            const roundState = state.topicState[vueltaId];
            const roundInfo = state.rounds.find(r => r.vueltaId === vueltaId);
            if (roundState && roundState.assigned && roundInfo) {
                for (const dayIndex in roundState.assigned) {
                    const topic = roundState.assigned[dayIndex].find(t => t.id === topicId);
                    if (topic) {
                        const date = new Date(roundInfo.startDate);
                        date.setUTCDate(date.getUTCDate() + parseInt(dayIndex, 10));
                        return { status: 'assigned', date: date.toISOString().split('T')[0] };
                    }
                }
            }

            return null; // Not found in this specific round
        }


        /**
         * Navigates the calendar to the month of the assigned topic and highlights the day.
         * @param {string} topicId - The full ID of the topic to find.
         * @param {string} vueltaId - The specific round context for the search.
         */
        function navigateToTopicDate(topicId, vueltaId) {
            // Prioritize searching in the specific round context provided
            let assignment = findTopicAssignmentInVuelta(topicId, vueltaId);

            // As a fallback, if not found in the specific round (which would be an inconsistent state),
            // search globally. This maintains robustness.
            if (!assignment || !assignment.date) {
                console.warn(`Could not find topic ${topicId} in its expected round ${vueltaId}. Falling back to global search.`);
                assignment = findTopicGlobalAssignment(topicId);
            }

            if (assignment.status === 'unassigned' || !assignment.date) {
                console.log(`Topic ${topicId} is not assigned to a date.`);
                return;
            }

            const dateStr = assignment.date;
            const targetDate = new Date(dateStr + 'T00:00:00Z');

            // Set the displayDate to the month of the target date
            state.displayDate = new Date(Date.UTC(targetDate.getUTCFullYear(), targetDate.getUTCMonth(), 1));

            // Re-render the calendar to show the correct month
            renderCalendar();

            // The calendar is re-rendered, so we need a brief delay
            // for the element to be available in the DOM.
            setTimeout(() => {
                const dayCell = document.querySelector(`.calendar-day[data-date="${dateStr}"]`);
                if (dayCell) {
                    dayCell.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    dayCell.classList.add('highlight-day');
                    setTimeout(() => {
                        dayCell.classList.remove('highlight-day');
                    }, 1500); // Keep highlight for 1.5 seconds
                }
            }, 100); // 100ms delay should be enough
        }

        function handleDragStartFromSource(e) {
            const topicId = e.target.dataset.topicId;
            const isSelected = state.selectedTopics.includes(topicId);

            if (!isSelected) {
                document.querySelectorAll('#topic-source-list .topic-card.selected').forEach(card => card.classList.remove('selected'));
                state.selectedTopics = [topicId];
                e.target.classList.add('selected');
            }
            
            e.target.classList.add('dragging');
            
            state.draggedTopic = {
                ids: [...state.selectedTopics],
                from: 'source',
                vuelta: state.currentVuelta
            };
        }
        
        function handleDragStartFromCalendar(e) {
            e.stopPropagation();
            e.target.classList.add('dragging');
            
            const isStudied = e.target.dataset.isStudied === 'true';
            const topicId = e.target.dataset.topicId;

            if (isStudied) {
                 state.draggedTopic = {
                    ids: [topicId],
                    from: 'calendar_fixed',
                    sourceDate: e.target.closest('.calendar-day').dataset.date,
                    originalVuelta: e.target.dataset.originalVuelta
                };
            } else {
                state.draggedTopic = {
                    ids: [topicId],
                    from: 'calendar_relative',
                    sourceVuelta: e.target.dataset.sourceVuelta,
                    sourceDayIndex: parseInt(e.target.dataset.sourceDayIndex, 10)
                };
            }
        }
        
        function handleDragEnd(e) {
            if (state.draggedTopic) {
                const draggingElement = document.querySelector('.dragging');
                if (draggingElement) {
                    draggingElement.classList.remove('dragging');
                }
                state.draggedTopic = null;
            }
        }

        function handleDragOver(e) { e.preventDefault(); e.currentTarget.classList.add('drag-over'); }
        function handleDragLeave(e) { e.currentTarget.classList.remove('drag-over'); }

        function handleDropOnCalendar(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            if (!state.draggedTopic) return;

            const dateStr = e.currentTarget.dataset.date;
            const draggedIds = state.draggedTopic.ids;
            const dropDate = new Date(dateStr + 'T00:00:00Z');
            const targetRound = state.rounds.find(r => dropDate >= r.startDate && dropDate <= r.endDate);

            if (!targetRound) return; 
            
            const targetDayIndex = Math.round((dropDate - targetRound.startDate) / (1000 * 60 * 60 * 24));

            // Logic for moving from source list
            if (state.draggedTopic.from === 'source') {
                if (targetRound.vueltaId !== state.currentVuelta) {
                    e.currentTarget.classList.add('drop-invalid');
                    setTimeout(() => e.currentTarget.classList.remove('drop-invalid'), 500);
                    return;
                }

                const roundState = state.topicState[state.currentVuelta];
                
                draggedIds.forEach(topicId => {
                    const topicIndex = roundState.unassigned.indexOf(topicId);
                    if (topicIndex > -1) {
                        roundState.unassigned.splice(topicIndex, 1);
                        if (!roundState.assigned[targetDayIndex]) roundState.assigned[targetDayIndex] = [];
                        roundState.assigned[targetDayIndex].push({ id: topicId, studied: false });
                    }
                });
                
                state.selectedTopics = [];
                renderTopicSourceList();
                updateSingleDay(dateStr);
                renderSummaryTable();
            } 
            // Logic for moving a relative (unstudied) topic
            else if (state.draggedTopic.from === 'calendar_relative') {
                const topicId = draggedIds[0]; // Only one topic can be dragged from calendar
                const { sourceVuelta, sourceDayIndex } = state.draggedTopic;
                
                if (sourceVuelta === targetRound.vueltaId && sourceDayIndex === targetDayIndex) return;

                const sourceRoundState = state.topicState[sourceVuelta];
                const sourceDayTopics = sourceRoundState.assigned[sourceDayIndex];
                const topicIndex = sourceDayTopics.findIndex(t => t.id === topicId);
                
                if (topicIndex > -1) {
                    const [movedTopic] = sourceDayTopics.splice(topicIndex, 1);
                    if(sourceDayTopics.length === 0) delete sourceRoundState.assigned[sourceDayIndex];

                    const targetRoundState = state.topicState[targetRound.vueltaId];
                    if (!targetRoundState.assigned[targetDayIndex]) targetRoundState.assigned[targetDayIndex] = [];
                    targetRoundState.assigned[targetDayIndex].push(movedTopic);

                    const sourceRoundInfo = state.rounds.find(r => r.vueltaId === sourceVuelta);
                    const sourceDate = new Date(sourceRoundInfo.startDate);
                    sourceDate.setUTCDate(sourceDate.getUTCDate() + sourceDayIndex);
                    
                    updateSingleDay(sourceDate.toISOString().split('T')[0]);
                    updateSingleDay(dateStr);
                    renderSummaryTable();
                }
            }
            // Cannot drag-and-drop studied (fixed) topics. They must be un-studied first.

            state.draggedTopic = null;
            document.querySelector('.dragging')?.classList.remove('dragging');
        }

        function handleDropOnSourceList(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            if (!state.draggedTopic || !state.draggedTopic.from.startsWith('calendar')) return;

            const { ids } = state.draggedTopic;
            const topicId = ids[0]; // Only one topic at a time from calendar
            
            const vueltaToReturnTo = state.draggedTopic.from === 'calendar_fixed' 
                ? state.draggedTopic.originalVuelta 
                : state.draggedTopic.sourceVuelta;
            
            unassignTopic(topicId, vueltaToReturnTo);

            state.draggedTopic = null;
            document.querySelector('.dragging')?.classList.remove('dragging');
        }

        function exportToCSV() {
            let csvContent = "data:text/csv;charset=utf-8,tipo,vuelta,dia,id_tema,bloque,estudiado,seguridad\r\n";
            // Studied topics
            for(const dateStr in state.topicState.studiedTopics) {
                state.topicState.studiedTopics[dateStr].forEach(topicData => {
                    const topicInfo = state.flatTopics.find(t => t.fullId === topicData.id);
                    if (topicInfo) {
                        const security = topicData.securityLevel || '';
                        const row = ['fijo', topicData.originalVuelta, dateStr, `"${topicData.id}"`, `"${topicInfo.block}"`, topicData.studied, security].join(",");
                        csvContent += row + "\r\n";
                    }
                });
            }
            // Relative topics
            for (const vueltaId in state.topicState) {
                if(vueltaId === 'studiedTopics' || !state.topicState[vueltaId].assigned) continue;
                const roundData = state.topicState[vueltaId];
                for (const dayIndex in roundData.assigned) {
                    roundData.assigned[dayIndex].forEach(topicData => {
                        const topicInfo = state.flatTopics.find(t => t.fullId === topicData.id);
                        if (topicInfo) {
                            const row = ['relativo', vueltaId, dayIndex, `"${topicData.id}"`, `"${topicInfo.block}"`, topicData.studied, ''].join(",");
                            csvContent += row + "\r\n";
                        }
                    });
                }
            }

            const encodedUri = encodeURI(csvContent);
            const link = document.createElement("a");
            link.setAttribute("href", encodedUri);
            link.setAttribute("download", `plan_estudio_${sessionId}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        } 

        function importFromCSV(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                const rows = text.split('\n').slice(1);
                
                resetTopicState();

                rows.forEach(row => {
                    if (!row) return;
                    const columns = row.split(',').map(c => c.replace(/"/g, ''));
                    const [tipo, vueltaId, dia, topicId, block, studiedStr, securityStr] = columns;
                    
                    if (!tipo || !vueltaId || !dia || !topicId) return;

                    const studied = studiedStr.trim() === 'true';
                    const securityLevel = securityStr ? parseInt(securityStr, 10) : undefined;

                    if (tipo === 'fijo') {
                        const dateStr = dia;
                         if (!state.topicState.studiedTopics[dateStr]) { 
                            state.topicState.studiedTopics[dateStr] = [];
                        }
                        const topicObject = { id: topicId, studied: studied, originalVuelta: vueltaId };
                        if (securityLevel) {
                            topicObject.securityLevel = securityLevel;
                        }
                        state.topicState.studiedTopics[dateStr].push(topicObject);
                    } else { // relativo
                        const dayIndex = parseInt(dia, 10);
                        if (isNaN(dayIndex) || !state.topicState[vueltaId]) return;
                        const roundState = state.topicState[vueltaId];
                         if (!roundState.assigned[dayIndex]) {
                            roundState.assigned[dayIndex] = [];
                        }
                        roundState.assigned[dayIndex].push({ id: topicId, studied: studied });
                    }
                    
                    // Remove from unassigned
                    for(const vId in state.topicState){
                        if(vId === 'studiedTopics' || !state.topicState[vId].unassigned) continue;
                        const unassignedIndex = state.topicState[vId].unassigned.indexOf(topicId);
                        if (unassignedIndex > -1) {
                            state.topicState[vId].unassigned.splice(unassignedIndex, 1);
                        }
                    }
                });
                alert('¡Plan importado con éxito!');
                renderAll();
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        initialize();
    </script>
</body>
</html>
